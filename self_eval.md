# Self-Evaluation

- Reflect on your learning and work today. What are you most proud of?
- What is the power of using methods in our applications?

1. What am I most proud of? I would say my ability to now quickly find answers to questions I have that are beyond the scope of the lessons and teaching so far. I had gotten so used to using MDN and Stack Overflow for any JavaScript questions, taking those two resources for granted in being able to answer just about every question I have ever had. I was struggling to find similar resources for Ruby. Ruby docs definitely has all the info, I'm sure, but I wasn't as comfortable yet finding the topic quickly and getting my answer. However, more recently I have been able to articulate my Ruby questions with more detail and relevance so that on first search I'm often now able to find exactly what I'm looking for and I'm able to quickly understand and implement the new information. I'm definitely starting to get used the the syntax which, initially, was also giving me some frustration and aggravation. In fact, I'm realizing that Ruby has, seemingly, many more ways to solve the same problem than JavaScript. And even comes with functions much more convenient -> I explain this in the built_in_methods.rb file with regards to the Array.sum function, and how convenient it is when compared to anything JavaScript has available.

1. Reuse is a critical aspect that makes methods so powerful. Often, we ourselves quickly notice how common we are solving a similar problem. Particularly at the lower, more granular level. Rather than having to recreate the same or similar code over and over, we can use functions we've built ourselves. What really makes reuse so powerful though, is that we can access and reuse methods that an entire community of developers have already created to solve common problems. Some of these problems can also be incredibly complex - like having two devices communicate with eachother on a massive world-wide network. This, obviously, became quite a common problem beginning in the mid-late nineties, but it also would have been an incredibly difficult one for most developers to solve. We take it for granted now, with methods and classes developed years ago that abstracted away the complexity, allowing those with little experience quickly follow instructions online to create their own apps, and quickly, that can access the Internet and communicate with devices or access the most up-to-date and relevant information for their own programs to interact with.

1. (cont'd) In addition to reusability, abstracting away details is instrumental in helping developers debug their code or modify complex methods so that the code can be flexible and fit specific users' needs. Not only would it be incredibly difficult always having to figure out the logic of someone else's code, it would make programs impossibly convoluted, verbose, and difficult to debug.

1. (cont'd) Further, if a developer refactored their program to make it more efficient, or becuase a new standard had been adopted, or because some change in their operation made it necessary, if you implemented functional (or methods) in your programming, you only have to update or fix this code in one place - in the method. A method might be used hundreds or thousands of times in a program. Having to fix it in every location would be prohibitively inefficient.

Methods will also allow the protection of data as encapsulation is also a huge benefit of working with methods (and, obviously these benefits are pillars of OOP). Only allowing a method that has some pre-programmed functions that would allow users to manipulate sensitive data is imperative and keeps data both safe and prevents the wrong types of data from corrupting a program and bringing down a system. Which, without the appropriate checks and balances that methods can provide, would be much more common and, again, productively prohibitive.
